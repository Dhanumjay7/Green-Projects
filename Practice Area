/**
 * @NApiVersion 2.0
 * @NScriptType MapReduceScript
 * @NModuleScope SameAccount
 */
define([
    'N/search','N/record','N/runtime','N/xml','N/file','N/render',
    'N/url','N/encode','N/email','N/format','N/task'
], function(search, record, runtime, xmlMod, file, render, url, encode, email, format, task) {

    // ====== CONFIG ======
    var defaultEmpID = 215516;
    var folderID = 148222;
    var templateDefault = 25;
    var brazilTemplate = 26;
    var logoDefault = '3662874';
    var logoBrazil = '3662875';

    var statementScript = runtime.getCurrentScript();
    var FILE_CONST = {
        SEARCH_INPUT: statementScript.getParameter({ name: 'custscript_weeklyst_searchinput' }),
        SEARCH_TRANSACTIONS: statementScript.getParameter({ name: 'custscript_weeklyst_searchtransactions' }),
        ARRIVAL_DATE: statementScript.getParameter({ name: 'custscript_weeklyst_searcharrivaldate' }) || '',
        RESUME_FROM_CUSTOMER: statementScript.getParameter({ name: 'custscript_resume_from_customer' }) || ''
    };

    // ====== Debug/resume helpers ======
    var globalStartTime = null;
    function shouldRescheduleCheckpoint(lastCustomer) {
        var script = runtime.getCurrentScript();
        var remaining = script.getRemainingUsage();
        var elapsed = (new Date().getTime() - globalStartTime);
        // thresholds: tweak if needed
        if (remaining < 300 || elapsed > (48 * 60 * 1000)) { // ~48 minutes OR low governance
            log.audit('shouldRescheduleCheckpoint triggered', 'remaining=' + remaining + ' elapsed(ms)=' + elapsed + ' lastCust=' + lastCustomer);
            try {
                rescheduleMapReduce(lastCustomer);
            } catch (e) {
                log.error('Reschedule failed in checkpoint', e);
            }
            return true;
        }
        return false;
    }

    // ====== entry points ======
    function getInputData() {
        globalStartTime = new Date().getTime();
        log.audit("getInputData begin", new Date());
        var statementSearch = search.load(FILE_CONST.SEARCH_INPUT);
        var defValue = statementScript.getParameter({ name: 'custscript_customerfilter' });
        if (defValue) {
            var paramFilter = search.createFilter({
                name: 'internalid',
                join: 'customer',
                operator: 'anyof',
                values: defValue
            });
            statementSearch.filters.push(paramFilter);
        }
        if (FILE_CONST.RESUME_FROM_CUSTOMER) {
            var resumeFilter = search.createFilter({
                name: 'internalidnumber',
                join: 'customer',
                operator: 'greaterthan',
                values: FILE_CONST.RESUME_FROM_CUSTOMER
            });
            statementSearch.filters.push(resumeFilter);
        }
        return statementSearch;
    }

    // ====== REDUCE: process each key's values, with frequent reschedule checks ======
    function reduce(context) {
        // ensure globalStartTime exists
        if (!globalStartTime) globalStartTime = new Date().getTime();

        // each context.key may contain one or multiple grouped values; process them sequentially
        for (var i in context.values) {
            // quick governance/time check at top of each iteration
            var remainingBefore = runtime.getCurrentScript().getRemainingUsage();
            if (shouldRescheduleCheckpoint(context.key)) {
                log.audit('reduce: rescheduled before processing value', 'key=' + context.key);
                return; // stop this worker
            }

            try {
                var tranData = JSON.parse(context.values[i]).values;
                var custId = tranData["GROUP(entity)"].value;
                log.audit('reduce processing customer', custId);

                // more frequent soft-check: if near low governance, reschedule BEFORE heavy operations
                var rem = runtime.getCurrentScript().getRemainingUsage();
                if (rem < 400) { // tune threshold
                    log.audit('Low governance before heavy work, rescheduling', 'cust=' + custId + ' remaining=' + rem);
                    rescheduleMapReduce(custId);
                    return;
                }

                var statementDate = getStatementDate();

                // load customer (non-dynamic for speed)
                var customerRecord = record.load({ type: 'customer', id: custId });
                var cusObj = buildCustomerObject(customerRecord, custId);

                // get transactions for each currency - use streaming where possible
                var attachmentArr = [];
                var currencyList = [1,2,4];
                for (var c = 0; c < currencyList.length; c++) {
                    var currency = currencyList[c];

                    // BEFORE running heavy searches, check governance/time
                    if (shouldRescheduleCheckpoint(custId)) return;

                    var resultsAmount = getTransactions(custId, currency); // this function streams and checks governance
                    if (!resultsAmount || resultsAmount.length === 0) continue;

                    var netAmount = getBalance(custId, resultsAmount, currency);
                    if (!netAmount || parseFloat(netAmount) <= 0) continue;

                    // CHECK governance again: pdf generation is expensive
                    var remainingNow = runtime.getCurrentScript().getRemainingUsage();
                    if (remainingNow < 500) {
                        log.audit('Not enough governance to generate PDF - rescheduling', 'cust=' + custId + ' remaining=' + remainingNow);
                        rescheduleMapReduce(custId);
                        return;
                    }

                    var files = createPDF(cusObj, netAmount, resultsAmount, statementDate, currency);
                    if (files) {
                        attachmentArr.push(files.pdf);
                        attachmentArr.push(files.excel);
                    }

                    // small checkpoint after heavy file creation
                    if (shouldRescheduleCheckpoint(custId)) return;
                }

                if (attachmentArr.length) {
                    sendEmail(cusObj, statementDate, attachmentArr);

                    // update last statement date
                    record.submitFields({ type: 'customer', id: custId, values: { custentity_upaya_last_statement_date: statementDate } });
                }

                log.audit('reduce done for customer', custId);

            } catch (e) {
                log.error('Reduce error for key ' + context.key, e);
                // continue processing next value unless runtime forced us to stop
            }

            // mid-loop governance check
            if (shouldRescheduleCheckpoint(context.key)) return;
        }
    }

    // ====== summarize ======
    function summarize(summary) {
        log.audit('Summary', JSON.stringify(summary));
        // existing summary error handling
        handleSummaryErrors(summary);
    }

    function handleSummaryErrors(summary) {
        if (summary.inputSummary && summary.inputSummary.error) log.error('Input Summary Error', summary.inputSummary.error);
        summary.mapSummary && summary.mapSummary.errors && summary.mapSummary.errors.iterator().each(function(k,e) { log.error('Map Error ' + k, e); return true; });
        summary.reduceSummary && summary.reduceSummary.errors && summary.reduceSummary.errors.iterator().each(function(k,e) { log.error('Reduce Error ' + k, e); return true; });
    }

    // ====== Reschedule helper ======
    function rescheduleMapReduce(lastCustomerId) {
        try {
            var curScript = runtime.getCurrentScript();
            var mrTask = task.create({ taskType: task.TaskType.MAP_REDUCE });
            mrTask.scriptId = curScript.id;
            mrTask.deploymentId = curScript.deploymentId;
            mrTask.params = { custscript_resume_from_customer: lastCustomerId || '' };
            var taskId = mrTask.submit();
            log.audit('Rescheduled MR', 'taskId=' + taskId + ' resumeFrom=' + lastCustomerId);
        } catch (e) {
            log.error('RescheduleMapReduce failed', e);
            throw e;
        }
    }

    // ====== Customer builder (non-dynamic) ======
    function buildCustomerObject(customerRecord, custId) {
        var obj = {};
        obj.cname = custId;
        obj.customerName = customerRecord.getValue('isperson') ? customerRecord.getValue('altname') : customerRecord.getValue('companyname');
        obj.arSpecialist = customerRecord.getValue('custentity_bonotel_ar_specialist');
        obj.customerEmail = customerRecord.getValue('custentity_2663_email_address_notif');
        obj.customerTemplate = customerRecord.getValue('custentity_custom_email_template');

        var addrCount = customerRecord.getLineCount({ sublistId: 'addressbook' });
        for (var a = 0; a < addrCount; a++) {
            var isDefaultBilling = customerRecord.getSublistValue({ sublistId: 'addressbook', fieldId: 'defaultbilling', line: a });
            if (isDefaultBilling) {
                var addressSubrecord = customerRecord.getSublistSubrecord({ sublistId: 'addressbook', fieldId: 'addressbookaddress', line: a });
                if (addressSubrecord) {
                    obj.customeraddress = addressSubrecord.getValue({ fieldId: 'addr1' }) || '';
                    obj.city = addressSubrecord.getValue({ fieldId: 'city' }) || '';
                    obj.state = addressSubrecord.getValue({ fieldId: 'state' }) || '';
                    obj.zip = addressSubrecord.getValue({ fieldId: 'zip' }) || '';
                    obj.country = addressSubrecord.getValue({ fieldId: 'country' }) || '';
                }
                break;
            }
        }
        return obj;
    }

    // ====== Helpers commonly used ======
    function isEmpty(value) {
        if (value === null || value === undefined) return true;
        if (typeof value === 'string' && value.trim() === '') return true;
        if (Array.isArray(value) && value.length === 0) return true;
        return false;
    }
    function getnumber(id) { var ret = parseFloat(id); if (isNaN(ret)) ret = 0; return ret; }
    function formatAmount(nStr) { nStr = (nStr === null || nStr === undefined) ? '0' : String(nStr); var x = nStr.split('.'); var x1 = x[0]; var x2 = x.length>1?'.'+x[1]:''; var rgx=/(\d+)(\d{3})/; while(rgx.test(x1)){ x1 = x1.replace(rgx,'$1'+','+'$2'); } return x1 + x2; }
    function formatMoney(value) { if (value === null || value === undefined || value === '') return '0.00'; var num = parseFloat(value); if (isNaN(num)) num = 0; return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2}); }
    function getTimestamp() { var now=new Date(); var y=''+now.getFullYear(); var m=('0'+(now.getMonth()+1)).slice(-2); var d=('0'+now.getDate()).slice(-2); var hh=('0'+now.getHours()).slice(-2); var mm=('0'+now.getMinutes()).slice(-2); var ss=('0'+now.getSeconds()).slice(-2); return y+m+d+hh+mm+ss; }
    function loadCurrency(currencyId) { var rec = record.load({ type:'currency', id: currencyId }); var obj = {}; obj.symbol = rec.getValue({ fieldId: 'displaysymbol' }) || '$'; obj.code = rec.getValue({ fieldId: 'symbol' }) || ''; return obj; }
    function getStatementDate() { var now=new Date(); var year=''+now.getFullYear(); var month=('0'+(now.getMonth()+1)).slice(-2); var day=('0'+now.getDate()).slice(-2); return month+'/'+day+'/'+year; }
    function days_between(date1, date2) { var ONE_DAY = 1000*60*60*24; var date1_date = (typeof date1=='string')?format.parse({value:date1,type:format.Type.DATE}):date1; var date2_date = (typeof date2=='string')?format.parse({value:date2,type:format.Type.DATE}):date2; return Math.round((date1_date.getTime()-date2_date.getTime())/ONE_DAY); }

    // ====== runPaged with governance-aware break ======
    function runSearchPaged(recType, searchId, filters) {
        if (!recType && !searchId) return [];
        var searchRec;
        if (searchId) {
            searchRec = search.load({ id: searchId });
            if (filters && filters.length) for (var f=0; f<filters.length; f++) searchRec.filters.push(filters[f]);
        } else searchRec = search.create({ type: recType, filters: filters });

        var allResults = [];
        try {
            var paged = searchRec.runPaged({ pageSize: 1000 });
            var pageRanges = paged.pageRanges;
            for (var p = 0; p < pageRanges.length; p++) {
                var page = paged.fetch({ index: pageRanges[p].index });
                var pageData = page.data;
                for (var r = 0; r < pageData.length; r++) allResults.push(pageData[r]);
                var remaining = runtime.getCurrentScript().getRemainingUsage();
                if (remaining < 200) { log.audit('runSearchPaged stopping (low governance)', 'remaining=' + remaining); break; }
            }
        } catch (err) {
            log.error('runSearchPaged error', err);
            throw err;
        }
        return allResults;
    }

    // ====== Improved getTransactions: streaming run and governance checks ======
    function getTransactions(cname, currency) {
        // Build filters split by mid date if needed (keeps logic same as yours)
        var results = [];
        try {
            if (!isEmpty(FILE_CONST.ARRIVAL_DATE)) {
                var filtersArrival = [
                    search.createFilter({ name: 'entity', operator: 'anyof', values: cname }),
                    search.createFilter({ name: 'custbody_arrival_date', operator: 'onorafter', values: FILE_CONST.ARRIVAL_DATE }),
                    search.createFilter({ name: 'currency', operator: 'anyof', values: currency })
                ];
                results = runSearchPaged('transaction', FILE_CONST.SEARCH_TRANSACTIONS, filtersArrival) || [];
            } else {
                // Use the same midDate split as your original (to avoid expensive large single search)
                var startdate = new Date(2016,0,1), enddate = new Date();
                var middate = new Date((startdate.getTime() + enddate.getTime())/2);
                var midDateStr = String(middate.getMonth()+1)+'/'+String(middate.getDate())+'/'+String(middate.getFullYear());

                var filtersOlder = [
                    search.createFilter({ name: 'entity', operator: 'anyof', values: cname }),
                    search.createFilter({ name: 'custbody_arrival_date', operator: 'before', values: midDateStr }),
                    search.createFilter({ name: 'currency', operator: 'anyof', values: currency })
                ];
                var filtersNewer = [
                    search.createFilter({ name: 'entity', operator: 'anyof', values: cname }),
                    search.createFilter({ name: 'custbody_arrival_date', operator: 'onorafter', values: midDateStr }),
                    search.createFilter({ name: 'currency', operator: 'anyof', values: currency })
                ];

                var resA = runSearchPaged('transaction', FILE_CONST.SEARCH_TRANSACTIONS, filtersOlder) || [];
                if (shouldRescheduleCheckpoint(cname)) return resA.concat([]); // return partial; will resume
                var resB = runSearchPaged('transaction', FILE_CONST.SEARCH_TRANSACTIONS, filtersNewer) || [];
                results = resA.concat(resB);
            }
            return results;
        } catch (err) {
            log.error('getTransactions error', err);
            if (err && err.name === 'SSS_SEARCH_TIMEOUT') {
                // reschedule and stop
                try { rescheduleMapReduce(cname); } catch (e) { log.error('reschedule after timeout failed', e); }
            }
            throw err;
        }
    }

    // ====== getBalance unchanged but defensive ======
    function getBalance(cname, resultsAmount, currency) {
        var clientBalance = 0;
        var typeCol = search.createColumn({ name: 'type' });
        var custDueDateCol = search.createColumn({ name: 'custbody_due_date' });
        var dueDateCol = search.createColumn({ name: 'duedate' });

        for (var aa = 0; resultsAmount != null && aa < resultsAmount.length; aa++) {
            var resultsGetAmount = resultsAmount[aa];
            var _type = resultsGetAmount.getValue(typeCol);
            var depamt = parseFloat(resultsGetAmount.getValue('custbody_total_earmarks')) || 0;
            var amt = (currency == 1) ? parseFloat(resultsGetAmount.getValue('amount')) || 0 : parseFloat(resultsGetAmount.getValue('fxamount')) || 0;
            var remaining = getnumber(amt) - getnumber(depamt);
            if (_type === 'SalesOrd') {
                remaining = getnumber(amt) - getnumber(depamt);
            } else {
                remaining = (currency == 1) ? parseFloat(resultsGetAmount.getValue('amountremaining')) || 0 : parseFloat(resultsGetAmount.getValue('fxamountremaining')) || 0;
            }

            var dueDate = '';
            if (!isEmpty(resultsGetAmount.getValue(custDueDateCol))) dueDate = resultsGetAmount.getValue(custDueDateCol); else dueDate = resultsGetAmount.getValue(dueDateCol);

            if (!dueDate) {
                log.audit('getBalance: missing due date, returning undefined to skip customer', resultsGetAmount.getValue('internalid'));
                return;
            }
            if (remaining > 0) clientBalance += remaining;

            // governance check inside heavy loop
            if (runtime.getCurrentScript().getRemainingUsage() < 150) {
                log.audit('getBalance: low governance, breaking out early', 'cust=' + cname);
                break;
            }
        } // loop

        var netAmount = formatAmount(clientBalance.toFixed(2));
        if (netAmount === '0.00') return '';
        return netAmount;
    }

    // ====== createPDF/sendEmail (kept as before but with small governance checks) ======
    function createPDF(cusObj, netAmount, resultsAmount, statementDate, currency) {
        // Keep the heavy PDF/Excel creation logic mostly as you had it.
        // We include governance checks before render.xmlToPdf and saving files.
        var currencyObj = loadCurrency(currency);
        var currencySymbol = currencyObj.symbol;
        var currencyCode = currencyObj.code;
        var cname = cusObj.cname;
        var customerName = cusObj.customerName || 'Unknown';
        var customerTemplate = cusObj.customerTemplate;
        var customeraddress = cusObj.customeraddress || '';
        var city = cusObj.city || '';
        var state = cusObj.state || '';
        var zip = cusObj.zip || '';
        var country = cusObj.country || '';
        var today = getTimestamp();

        // Build excel xml and html parts (similar to your original). For brevity I keep structure compact.
        var strNamePic = "<table><tr><td>";
        try {
            var img = (customerTemplate == brazilTemplate) ? file.load({id: logoBrazil}) : file.load({id: logoDefault});
            strNamePic += xmlMod.escape({ xmlText: img.url });
        } catch (e) {
            log.error('logo load', e);
        }
        strNamePic += "</td></tr></table>";

        // --- build item rows & excel xml ---
        var xmlString = '<?xml version="1.0"?><?mso-application progid="Excel.Sheet"?>';
        xmlString += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet">';
        xmlString += '<Worksheet ss:Name="Sheet1"><Table>';
        xmlString += '<Row><Cell><Data ss:Type="String">Name</Data></Cell><Cell><Data ss:Type="String">' + customerName + '</Data></Cell></Row>';
        xmlString += '<Row><Cell><Data ss:Type="String">Address</Data></Cell><Cell><Data ss:Type="String">' + customeraddress + '</Data></Cell></Row>';
        xmlString += '<Row><Cell><Data ss:Type="String">Statement Date</Data></Cell><Cell><Data ss:Type="String">' + statementDate + '</Data></Cell></Row>';
        xmlString += '<Row><Cell><Data ss:Type="String">Amount Due</Data></Cell><Cell><Data ss:Type="String">' + currencySymbol + ' ' + netAmount + '</Data></Cell></Row>';
        xmlString += '<Row></Row>';
        xmlString += '<Row><Cell><Data ss:Type="String">Provider</Data></Cell><Cell><Data ss:Type="String">Account</Data></Cell><Cell><Data ss:Type="String">Tran</Data></Cell><Cell><Data ss:Type="String">Booking</Data></Cell><Cell><Data ss:Type="String">DueDate</Data></Cell><Cell><Data ss:Type="String">Amount</Data></Cell><Cell><Data ss:Type="String">AmountRem</Data></Cell></Row>';

        // build HTML table for PDF
        var strName2 = '<table width="100%" border="1" style="border-collapse:collapse;">';
        strName2 += '<tr style="font-weight:bold;background-color:Gray;color:#FFF"><th>Hotel</th><th>Account</th><th>Tran</th><th>Booking</th><th>Due</th><th>Value</th><th>Amt Due</th></tr>';

        var agingCurrent=0, agingStage1=0, agingStage2=0, agingStage3=0, agingStage4=0, agingStage5=0;

        for (var i=0; resultsAmount && i<resultsAmount.length; i++) {
            var r = resultsAmount[i];
            var provider = r.getText({ name: 'custbody_provider_id' }) || '';
            var account = r.getValue({ name: 'altname', join: 'CUSTBODY_CUSTOMER_ACCOUNT' }) || '';
            var tranId = r.getValue({ name: 'tranid' }) || '';
            var booknum = r.getValue({ name: 'custbody_booking_number' }) || r.getValue({ name: 'name', join: 'CUSTBODY_TRANSACTION_RESERVATION_LINK' }) || '';
            var dueDate = r.getValue({ name: 'custbody_due_date' }) || r.getValue({ name: 'duedate' }) || '';
            var amount = (currency==1) ? r.getValue({ name: 'amount' }) : r.getValue({ name: 'fxamount' });
            var amountRem = (currency==1) ? r.getValue({ name: 'amountremaining' }) : r.getValue({ name: 'fxamountremaining' });
            amount = getnumber(amount); amountRem = getnumber(amountRem);

            if (amountRem > 0) {
                var agingdays = (dueDate) ? days_between(statementDate, dueDate) : 0;
                if (agingdays<=0) agingCurrent += amountRem; else if (agingdays<=30) agingStage1 += amountRem; else if (agingdays<=60) agingStage2 += amountRem; else if (agingdays<=90) agingStage3 += amountRem; else agingStage4 += amountRem;
                agingStage5 += amountRem;

                xmlString += '<Row><Cell><Data ss:Type="String">' + (provider || '') + '</Data></Cell><Cell><Data ss:Type="String">' + (account || '') + '</Data></Cell><Cell><Data ss:Type="String">' + (tranId || '') + '</Data></Cell><Cell><Data ss:Type="String">' + (booknum || '') + '</Data></Cell><Cell><Data ss:Type="String">' + (dueDate || '') + '</Data></Cell><Cell><Data ss:Type="String">' + formatMoney(amount) + '</Data></Cell><Cell><Data ss:Type="String">' + formatMoney(amountRem) + '</Data></Cell></Row>';
                strName2 += '<tr><td>' + xmlMod.escape({ xmlText: provider || '' }) + '</td><td>' + xmlMod.escape({ xmlText: account || '' }) + '</td><td>' + tranId + '</td><td>' + xmlMod.escape({ xmlText: booknum || '' }) + '</td><td>' + dueDate + '</td><td style="text-align:right">' + currencySymbol + ' ' + formatMoney(amount) + '</td><td style="text-align:right">' + currencySymbol + ' ' + formatMoney(amountRem) + '</td></tr>';
            }

            // governance check inside loop
            if (runtime.getCurrentScript().getRemainingUsage() < 200) {
                log.audit('createPDF: stopping item loop due to low governance', 'cust=' + cname);
                break;
            }
        }

        xmlString += '</Table></Worksheet></Workbook>';
        strName2 += '</table>';

        // create excel file (base64)
        var strXmlEncoded = encode.convert({ string: xmlString, inputEncoding: encode.Encoding.UTF_8, outputEncoding: encode.Encoding.BASE_64 });
        var objXlsFile = file.create({ name: (currency==2?'ExcelGBP_':'ExcelUSD_') + customerName + '_' + today + '.xls', fileType: file.Type.EXCEL, contents: strXmlEncoded });
        objXlsFile.folder = folderID;
        var fileID = objXlsFile.save();

        // PDF generation - check governance before render
        if (runtime.getCurrentScript().getRemainingUsage() < 400) {
            log.audit('Insufficient governance to generate PDF, rescheduling', 'cust=' + cname);
            rescheduleMapReduce(cname);
            // return partial results (we saved excel), let next run generate PDF
            return { pdf: fileID, excel: fileID }; // note: pdf is set to excel id for fallback; will be replaced next pass
        }

        // build final PDF xml
        var payLinkURL = getPayLinkURL(cname);
        var strPayLink = (isEmpty(payLinkURL) ? '' : '<table width="100%"><tr><td align="right"><a href="' + xmlMod.escape({ xmlText: payLinkURL }) + '">Click Here to Pay</a></td></tr></table>');
        var pdfXml = "<?xml version=\"1.0\"?>\n<!DOCTYPE pdf PUBLIC \"-//big.faceless.org//report\" \"report-1.1.dtd\">\n";
        pdfXml += "<pdf>\n<head><macrolist><macro id=\"myheader\"><p align=\"left\">" + strNamePic + "</p></macro><macro id=\"myfooter\"><p align=\"right\">Page <pagenumber/> of <totalpages/></p></macro></macrolist></head>";
        pdfXml += "<body font-size=\"7\" header=\"myheader\" header-height=\"20mm\" footer=\"myfooter\" footer-height=\"20mm'>";
        pdfXml += '<div>' + strName + '</div>' + strName2 + strPayLink;
        pdfXml += "</body></pdf>";

        var pdfFile = render.xmlToPdf({ xmlString: pdfXml });
        pdfFile.folder = folderID;
        pdfFile.name = 'PDF' + currencyCode + '_' + customerName + '_' + today + '.pdf';
        var fileID2 = pdfFile.save();

        // Attach files to customer
        try { record.attach({ record: { type: 'file', id: fileID2 }, to: { type: 'customer', id: cname } }); } catch (e) { log.error('attach pdf failed', e); }
        try { record.attach({ record: { type: 'file', id: fileID }, to: { type: 'customer', id: cname } }); } catch (e) { log.error('attach excel failed', e); }

        return { pdf: fileID2, excel: fileID };
    }

    function sendEmail(cusObj, statementDate, attachmentArr) {
        var cname = cusObj.cname;
        var customerName = cusObj.customerName;
        var customerEmail = cusObj.customerEmail;
        var customerTemplate = cusObj.customerTemplate;
        var emailTempId = (customerTemplate == brazilTemplate) ? brazilTemplate : (customerTemplate && customerTemplate.length>0 ? parseInt(customerTemplate) : templateDefault);
        var emailTemp = record.load({ type: 'emailtemplate', id: emailTempId });
        var emailBody = emailTemp.getValue('content');
        var recipients = [];
        if (!isEmpty(customerEmail)) recipients = customerEmail.split(';').map(function(s){return s.trim();});
        var fileLoadArr = [];
        for (var f=0; f<attachmentArr.length; f++) {
            try { fileLoadArr.push(file.load({ id: attachmentArr[f] })); } catch (e) { log.error('file.load failed', e); }
        }
        email.send({ author: defaultEmpID, recipients: recipients, subject: customerName + ' Statements for ' + statementDate, body: emailBody, attachments: fileLoadArr, relatedRecords: { entityId: cname } });
        log.audit('EMAIL SENT cname=' + cname, 'files=' + attachmentArr);
        return true;
    }

    function getPayLinkURL(custId) {
        var payLinkURL = '';
        try {
            var salesorderSearchObj = search.create({
                type: 'salesorder',
                filters: [
                    ['type','anyof','SalesOrd'],'AND',['mainline','is','T'],'AND',['status','anyof','SalesOrd:B'],'AND',['custbody_mes_invl_end_customer_link','isnotempty',''],'AND',['customermain.internalidnumber','equalto',custId]
                ],
                columns: [ search.createColumn({name:'trandate', sort: search.Sort.ASC}), search.createColumn({name:'tranid'}), search.createColumn({name:'custbody_mes_invl_end_customer_link'}) ]
            });
            var count = salesorderSearchObj.runPaged().count;
            if (count>0) {
                var r = salesorderSearchObj.run().getRange({ start:0, end:1 });
                payLinkURL = r[0].getValue({ name:'custbody_mes_invl_end_customer_link' }) || '';
            }
        } catch(e) { log.error('getPayLinkURL error', e); }
        return payLinkURL;
    }

    // ====== return entry points ======
    return {
        getInputData: getInputData,
        reduce: reduce,
        summarize: summarize
    };
});
