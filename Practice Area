function getInactiveVendorsOfDriverRecords() {

    // Step 1: get all driver records
    var drivers = getDriverSearch(); // cached
    var driverAgentMap = {};

    drivers.forEach(function (r) {
        driverAgentMap[r.getValue('custrecord_tlg_acs_agent_code')] = r.id;
    });

    // Step 2: collect inactive agent codes from PDF
    var inactiveAgents = [];

    runSearchPaged(search.load({ id: PARAMS.PDF_SEARCH })
        .filters.push(
            search.createFilter({ name: 'subsidiary', operator: 'anyof', values: PARAMS.SUB }),
            search.createFilter({ name: 'postingperiod', operator: 'anyof', values: PARAMS.PERIOD }),
            search.createFilter({ name: 'isinactive', join: 'custcol_tlg_agent_id', operator: 'is', values: 'T' })
        )
    ).forEach(function (r) {
        inactiveAgents.push(
            r.getValue({ name: 'custcol_agent_ext_id', summary: search.Summary.GROUP })
        );
    });

    // Step 3: collect inactive agent codes from COMM
    runSearchPaged(search.load({ id: PARAMS.COMM_SEARCH })
        .filters.push(
            search.createFilter({ name: 'custrecord_tlg_hotel_comm_subsidiary', operator: 'anyof', values: PARAMS.SUB }),
            search.createFilter({ name: 'custrecord_tlg_hotel_comm_period', operator: 'anyof', values: PARAMS.PERIOD }),
            search.createFilter({ name: 'isinactive', join: 'custrecordhotel_comm_ch_agentid', operator: 'is', values: 'T' })
        )
    ).forEach(function (r) {
        inactiveAgents.push(
            r.getValue({ name: 'custrecord_tlg_hotel_comm_agent_code', summary: search.Summary.GROUP })
        );
    });

    // Step 4: de-duplicate
    inactiveAgents = inactiveAgents.filter(function (v, i, a) {
        return a.indexOf(v) === i;
    });

    // Step 5: map back to Driver records (LEGACY output)
    var rows = [];
    inactiveAgents.forEach(function (agentCode) {
        if (driverAgentMap[agentCode]) {
            rows.push(
                'Driver Record:' +
                driverAgentMap[agentCode] + ':' +
                '' + ':' +
                agentCode + ':' +
                'Inactive Agent ID-' + agentCode
            );
        }
    });

    return rows;
}


function summarize(summary) {

    var rows = [];

    summary.output.iterator().each(function (_, value) {
        rows = rows.concat(value.split(','));
        return true;
    });

    // ðŸ”¹ Driver-level inactive vendors (PDF + COMM + Driver comparison)
    rows = rows.concat(getInactiveVendorsOfDriverRecords());

    if (!rows.length) return;

    var csv = "Record Type,Record ID,Document Number,Vendor ID,Message\n";

    rows.forEach(function (r) {
        var v = r.split(':');
        csv += v[0] + ',' + v[1] + ',' + v[2] + ',' + v[3] + ',' + v[4] + '\n';
    });

    var fileObj = file.create({
        name: 'ACS_Driver_Tieout_' + Date.now() + '.csv',
        fileType: file.Type.CSV,
        contents: csv,
        folder: PARAMS.FOLDER
    });

    var fileId = fileObj.save();

    var configRec = config.load({ type: config.Type.COMPANY_PREFERENCES });

    email.send({
        author: configRec.getValue('custscript_error_email_author'),
        recipients: runtime.getCurrentUser().email,
        subject: 'ACS Tieout Completed',
        body: 'ACS Tieout has been completed and the result file is attached.',
        attachments: [file.load({ id: fileId })]
    });
}

